(function(){"use strict";const c={HERO_HP:0,HERO_X:1,HERO_Y:2,REVISION:6,ENTITY_COUNT:8,ROCKS_START_INDEX:10,ROCK_STRIDE:3,MAX_ROCKS:1e3};class d{constructor(e){this.revisionIndex=e}isInitialized=!1;sharedView;intView;config=null;inputState={keys:[],isMouseDown:!1,isHovering:!1};setBuffer(e){this.sharedView=new Float32Array(e),this.intView=new Int32Array(e)}setInitialized(e){this.isInitialized=e,e&&this.onInitialize()}update(e,t,i,n){!this.isInitialized||!this.sharedView||!this.intView||(this.onUpdate(this.sharedView,this.intView,i,n),Atomics.add(this.intView,this.revisionIndex,1))}handleInput(e){if(e.action==="SYNC_INPUT"||e.action==="KEY_STATE"){this.inputState.keys=e.keys||[],this.inputState.isMouseDown=!!e.isMouseDown,this.inputState.isHovering=!!e.isHovering;return}this.dispatcher.dispatch(e.action,e)}destroy(){this.isInitialized=!1,this.config=null}getSnapshot(){return{}}loadSnapshot(e){}onInitialize(){}}class m{constructor(e,t,i="Dispatcher"){this.logic=e,this.commands=t,this.debugName=i}dispatch(e,t){const i=this.commands[e];i?i.execute(this.logic,t):console.warn(`[${this.debugName}] Unknown action: ${e}`)}}const y={INITIALIZE:{execute(s,e){s.applyConfig(e),s.setInitialized(!0)}},MOVEMENT:{execute(s,e){s.setMovement(e.vx,e.vy)}},TAKE_DAMAGE:{execute(s,e){const t=e.amount??15;s.modifyHp(-t)}}};class E extends d{dispatcher;hero={x:0,y:0,vx:0,vy:0,hp:100};rocks=[];currentFrame=0;lastHitFrame=0;constructor(){super(c.REVISION),this.dispatcher=new m(this,y,"Game1")}applyConfig(e){if(this.config=e,this.hero.hp=e.initialHP,this.hero.x=e.heroStartX,this.hero.y=e.heroStartY,this.rocks.length===0)for(let t=0;t<e.spawnCount;t++)this.spawnRock()}setMovement(e,t){e!==void 0&&(this.hero.vx=e),t!==void 0&&(this.hero.vy=t)}modifyHp(e){this.hero.hp=Math.max(0,Math.min(100,this.hero.hp+e)),e<0&&this.triggerHitCooldown()}triggerHitCooldown(){this.lastHitFrame=this.currentFrame}destroy(){super.destroy(),this.rocks=[]}getSnapshot(){return{hero:{...this.hero},rocks:[...this.rocks],lastHitFrame:this.lastHitFrame,currentFrame:this.currentFrame,config:this.config}}loadSnapshot(e){e&&(this.config=e.config,this.hero=e.hero,this.rocks=e.rocks,this.lastHitFrame=e.lastHitFrame,this.currentFrame=e.currentFrame??0,this.isInitialized=!0)}onUpdate(e,t,i,n){if(!this.config)return;this.currentFrame=i;const h=this.inputState.keys,o=this.config.moveSpeed;let l=0,r=0;(h.includes("W")||h.includes("ARROWUP"))&&(r=-o),(h.includes("S")||h.includes("ARROWDOWN"))&&(r=o),(h.includes("A")||h.includes("ARROWLEFT"))&&(l=-o),(h.includes("D")||h.includes("ARROWRIGHT"))&&(l=o),this.setMovement(l,r),this.currentFrame-this.lastHitFrame>120&&this.hero.hp<100&&(this.hero.hp=Math.min(100,this.hero.hp+(this.hero.hp<25?.3:.1))),this.hero.x=Math.max(0,Math.min(this.config.width,this.hero.x+this.hero.vx)),this.hero.y=Math.max(0,Math.min(this.config.height,this.hero.y+this.hero.vy)),this.processRocks(i),this.syncToSAB(e,i,n)}spawnRock(){!this.config||this.rocks.length>=c.MAX_ROCKS||this.rocks.push({x:Math.random()*this.config.width,y:Math.random()*this.config.height,vx:(Math.random()-.5)*8,vy:(Math.random()-.5)*8,seed:Math.random()*1e3})}processRocks(e){if(this.config)for(let t=this.rocks.length-1;t>=0;t--){const i=this.rocks[t];i.x+=i.vx,i.y+=i.vy;let n=!1;(i.x<=0||i.x>=this.config.width)&&(i.vx*=-1,n=!0),(i.y<=0||i.y>=this.config.height)&&(i.vy*=-1,n=!0);const h=i.x-this.hero.x,o=i.y-this.hero.y;h*h+o*o<1600&&(i.vx*=-1.1,i.vy*=-1.1,this.modifyHp(-.2),n=!0,self.postMessage({type:"EVENT",name:"EXPLOSION_REQ"})),n&&Math.random()>.8&&this.spawnRock()}}syncToSAB(e,t,i){e[c.HERO_HP]=this.hero.hp,e[c.HERO_X]=this.hero.x,e[c.HERO_Y]=this.hero.y,e[c.ENTITY_COUNT]=this.rocks.length,this.rocks.forEach((n,h)=>{const o=c.ROCKS_START_INDEX+h*c.ROCK_STRIDE;e[o]=n.x,e[o+1]=n.y,e[o+2]=n.seed})}}const p={HERO_HP:0,ENERGY:1,SCRAP_COUNT:2,TICK_COUNT:3,REVISION:6},I={INITIALIZE:{execute(s,e){s.applyConfig(e),s.setInitialized(!0)}},MOD_HP:{execute(s,e){s.modifyHp(e.amount)}},MOD_ENERGY:{execute(s,e){s.modifyEnergy(e.amount)}},ADD_SCRAP:{execute(s){s.addScrap(1)}}};class S extends d{dispatcher;hp=100;energy=50;scrap=0;currentFrame=0;constructor(){super(p.REVISION),this.dispatcher=new m(this,I,"Game2")}applyConfig(e){this.config=e,this.hp=e.initialHP,this.energy=e.initialEnergy,this.scrap=e.initialScrap}modifyHp(e){this.hp=Math.max(0,this.hp+e)}modifyEnergy(e){this.config&&(this.energy=Math.max(0,this.energy+e))}addScrap(e=1){this.scrap+=e}destroy(){super.destroy(),this.hp=100,this.energy=50,this.scrap=0}getSnapshot(){return{hp:this.hp,energy:this.energy,scrap:this.scrap,currentFrame:this.currentFrame,config:this.config}}loadSnapshot(e){e&&(this.config=e.config,this.hp=e.hp??100,this.energy=e.energy??50,this.scrap=e.scrap??0,this.isInitialized=!0)}onUpdate(e,t,i,n){this.config&&(this.currentFrame=i,i%this.config.regenRate===0&&this.energy<this.config.maxEnergy&&this.modifyEnergy(1),e[p.HERO_HP]=this.hp,e[p.ENERGY]=this.energy,e[p.SCRAP_COUNT]=this.scrap,e[p.TICK_COUNT]=i)}}let f,g,u;const a=new Map;self.onmessage=s=>{const{type:e,stateName:t,payload:i,frameCount:n,fps:h}=s.data;switch(e){case"INIT_SAB":console.log(`[Worker] Initializing SharedArrayBuffer for ${t||"global"}`),f=i.buffer,g=new Float32Array(f),u=new Int32Array(f),a.forEach((r,R)=>{typeof r.setBuffer=="function"&&(console.log(`[Worker] Updating buffer views for existing state: ${R}`),r.setBuffer(f))});break;case"CREATE_STATE":if(i?.force&&a.has(t)&&(console.warn(`[Worker] Force-recreating state: ${t}`),a.get(t).destroy(),a.delete(t)),!a.has(t)){console.log(`[Worker] Created Logic for: ${t}`);let r;t==="Game1"&&(r=new E),t==="Game2"&&(r=new S),r?(a.set(t,r),f&&r.setBuffer(f)):console.error(`[Worker] Failed to create logic instance for: ${t}`)}break;case"TERMINATE_STATE":a.has(t)?(console.log(`[Worker] Terminated Logic for: ${t}`),a.get(t).destroy(),a.delete(t)):console.warn(`[Worker] Attempted to terminate non-existent state: ${t}`);break;case"TERMINATE_ALL":console.log(`[Worker] Terminating all logic states. Count: ${a.size}`),a.forEach(r=>r.destroy()),a.clear();break;case"INPUT":const o=a.get(t);if(o)if(i.action==="GET_SNAPSHOT"){console.info(`[Worker] [${t}] Generating Snapshot`);const r=s.ports[0];r&&r.postMessage(o.getSnapshot())}else i.action==="LOAD_SNAPSHOT"?(console.info(`[Worker] [${t}] Loading Snapshot`),o.loadSnapshot(i.data)):(console.debug(`[Worker] [${t}] Input: ${i.action||"Unknown Action"}`),o.handleInput(i));else console.error(`[Worker] Received INPUT for unknown state: ${t}`);break;case"TICK":const l=a.get(t);l&&g&&u&&l.update(g,u,n,h);break;default:console.warn(`[Worker] Unhandled message type: ${e}`);break}}})();
