(function(){"use strict";const g={HERO_HP:0,HERO_X:1,HERO_Y:2,REVISION:6,ENTITY_COUNT:8},M={STRIDE:3};class k{constructor(t){this.revisionIndex=t}isInitialized=!1;sharedViews=new Map;intViews=new Map;config=null;inputState={actions:[],mouseX:0,mouseY:0,isMouseDown:!1,isHovering:!1};setBuffers(t){this.sharedViews.clear(),this.intViews.clear(),Object.entries(t).forEach(([s,e])=>{this.sharedViews.set(s,new Float32Array(e)),this.intViews.set(s,new Int32Array(e))})}get sharedView(){const t=this.sharedViews.get("main")||this.sharedViews.values().next().value;if(!t)throw new Error(`[BaseLogic] No SharedView available for ${this.constructor.name}`);return t}get intView(){const t=this.intViews.get("main")||this.intViews.values().next().value;if(!t)throw new Error(`[BaseLogic] No IntView available for ${this.constructor.name}`);return t}setInitialized(t){this.isInitialized=t,t&&this.onInitialize()}update(t,s,e,o){if(!this.isInitialized||this.sharedViews.size===0)return;this.onUpdate(this.sharedView,this.intView,e,o);const i=this.intView;i&&Atomics.add(i,this.revisionIndex,1)}handleInput(t){if(t.action==="SYNC_INPUT"){this.inputState.actions=t.actions||[],this.inputState.mouseX=t.mouseX||0,this.inputState.mouseY=t.mouseY||0,this.inputState.isMouseDown=!!t.isMouseDown,this.inputState.isHovering=!!t.isHovering;return}this.dispatcher.dispatch(t.action,t)}destroy(){this.isInitialized=!1,this.config=null}getSnapshot(){return{}}loadSnapshot(t){}onInitialize(){}}class S{constructor(t,s,e="Dispatcher"){this.logic=t,this.commands=s,this.debugName=e}dispatch(t,s){const e=this.commands[t];e?e.execute(this.logic,s):console.warn(`[${this.debugName}] Unknown action: ${t}`)}}const R={INITIALIZE:{execute(n,t){n.applyConfig(t),n.setInitialized(!0)}},MOVEMENT:{execute(n,t){n.setMovement(t.vx,t.vy)}},TAKE_DAMAGE:{execute(n,t){const s=t.amount??15;n.modifyHp(-s)}}};class I extends k{dispatcher;hero={x:0,y:0,vx:0,vy:0,hp:100};rocks=[];currentFrame=0;lastHitFrame=0;wasMouseDown=!1;constructor(){super(g.REVISION),this.dispatcher=new S(this,R,"Game1")}applyConfig(t){if(this.config=t,this.hero.hp=t.initialHP,this.hero.x=t.heroStartX,this.hero.y=t.heroStartY,this.rocks.length===0)for(let s=0;s<t.spawnCount;s++)this.spawnRock()}setMovement(t,s){t!==void 0&&(this.hero.vx=t),s!==void 0&&(this.hero.vy=s)}modifyHp(t){this.hero.hp=Math.max(0,Math.min(100,this.hero.hp+t)),t<0&&this.triggerHitCooldown()}triggerHitCooldown(){this.lastHitFrame=this.currentFrame}destroy(){super.destroy(),this.rocks=[]}getSnapshot(){return{hero:{...this.hero},rocks:[...this.rocks],lastHitFrame:this.lastHitFrame,currentFrame:this.currentFrame,config:this.config}}loadSnapshot(t){t&&(this.config=t.config,this.hero=t.hero,this.rocks=t.rocks,this.lastHitFrame=t.lastHitFrame,this.currentFrame=t.currentFrame??0,this.isInitialized=!0)}onUpdate(t,s,e,o){if(!this.config)return;this.currentFrame=e;const i=this.inputState.actions,r=this.config.moveSpeed;let a=0,c=0;if(i.includes("MOVE_UP")&&(c=-r),i.includes("MOVE_DOWN")&&(c=r),i.includes("MOVE_LEFT")&&(a=-r),i.includes("MOVE_RIGHT")&&(a=r),this.setMovement(a,c),this.inputState.isMouseDown&&!this.wasMouseDown){const E=this.inputState.mouseX*this.config.width,h=this.inputState.mouseY*this.config.height;this.spawnRock(E,h)}this.wasMouseDown=this.inputState.isMouseDown,this.currentFrame-this.lastHitFrame>120&&this.hero.hp<100&&(this.hero.hp=Math.min(100,this.hero.hp+(this.hero.hp<25?.3:.1))),this.hero.x=Math.max(0,Math.min(this.config.width,this.hero.x+this.hero.vx)),this.hero.y=Math.max(0,Math.min(this.config.height,this.hero.y+this.hero.vy)),this.processRocks(e),this.syncToSAB(t,e,o)}spawnRock(t,s){if(!this.config)return;const e=this.sharedViews.get("rocks");if(!e)return;const o=Math.floor(e.length/M.STRIDE);if(this.rocks.length>=o){const i=e.length+1e3*M.STRIDE;this._resizeRequested!==i&&(console.log(`[Game1Logic] Requesting Resize. Current: ${e.length}, New: ${i}`),self.postMessage({type:"REQUEST_RESIZE",payload:{bufferName:"rocks",newSize:i}}),this._resizeRequested=i);return}this._resizeRequested=0,this.rocks.push({x:t??Math.random()*this.config.width,y:s??Math.random()*this.config.height,vx:(Math.random()-.5)*8,vy:(Math.random()-.5)*8,seed:Math.random()*1e3})}processRocks(t){if(this.config)for(let s=this.rocks.length-1;s>=0;s--){const e=this.rocks[s];e.x+=e.vx,e.y+=e.vy;let o=!1;(e.x<=0||e.x>=this.config.width)&&(e.vx*=-1,o=!0),(e.y<=0||e.y>=this.config.height)&&(e.vy*=-1,o=!0);const i=e.x-this.hero.x,r=e.y-this.hero.y;i*i+r*r<1600&&(e.vx*=-1.1,e.vy*=-1.1,this.modifyHp(-.2),o=!0,self.postMessage({type:"EVENT",name:"EXPLOSION_REQ"})),o&&Math.random()>.8&&this.spawnRock()}}syncToSAB(t,s,e){const o=this.sharedViews.get("main"),i=this.sharedViews.get("rocks");o&&(o[g.HERO_HP]=this.hero.hp,o[g.HERO_X]=this.hero.x,o[g.HERO_Y]=this.hero.y,o[g.ENTITY_COUNT]=this.rocks.length),i&&this.rocks.forEach((r,a)=>{const c=a*M.STRIDE;c+2<i.length&&(i[c]=r.x,i[c+1]=r.y,i[c+2]=r.seed)})}}const d={HERO_HP:0,ENERGY:1,SCRAP_COUNT:2,TICK_COUNT:3,REVISION:6},v={INITIALIZE:{execute(n,t){n.applyConfig(t),n.setInitialized(!0)}},MOD_HP:{execute(n,t){n.modifyHp(t.amount)}},MOD_ENERGY:{execute(n,t){n.modifyEnergy(t.amount)}},ADD_SCRAP:{execute(n){n.addScrap(1)}}};class T extends k{dispatcher;hp=100;energy=50;scrap=0;currentFrame=0;constructor(){super(d.REVISION),this.dispatcher=new S(this,v,"Game2")}applyConfig(t){this.config=t,this.hp=t.initialHP,this.energy=t.initialEnergy,this.scrap=t.initialScrap}modifyHp(t){this.hp=Math.max(0,this.hp+t)}modifyEnergy(t){this.config&&(this.energy=Math.max(0,this.energy+t))}addScrap(t=1){this.scrap+=t}destroy(){super.destroy(),this.hp=100,this.energy=50,this.scrap=0}getSnapshot(){return{hp:this.hp,energy:this.energy,scrap:this.scrap,currentFrame:this.currentFrame,config:this.config}}loadSnapshot(t){t&&(this.config=t.config,this.hp=t.hp??100,this.energy=t.energy??50,this.scrap=t.scrap??0,this.isInitialized=!0)}onUpdate(t,s,e,o){this.config&&(this.currentFrame=e,e%this.config.regenRate===0&&this.energy<this.config.maxEnergy&&this.modifyEnergy(1),t[d.HERO_HP]=this.hp,t[d.ENERGY]=this.energy,t[d.SCRAP_COUNT]=this.scrap,t[d.TICK_COUNT]=e)}}const l={HERO_HP:0,HERO_X:1,HERO_Y:2,REVISION:6,ENTITY_COUNT:8,ROCKS_START_INDEX:10,ROCK_STRIDE:8,MAX_ROCKS:1e3},H={INITIALIZE:{execute(n,t){n.applyConfig(t),n.setInitialized(!0)}},MOVEMENT:{execute(n,t){n.setMovement(t.vx,t.vy)}},TAKE_DAMAGE:{execute(n,t){const s=t.amount??15;n.modifyHp(-s)}}};class O extends k{dispatcher;hero={x:0,y:0,vx:0,vy:0,hp:100};rocks=[];currentFrame=0;lastHitFrame=0;constructor(){super(l.REVISION),this.dispatcher=new S(this,H,"BHTest")}applyConfig(t){if(this.config=t,this.hero.hp=t.initialHP,this.hero.x=t.heroStartX,this.hero.y=t.heroStartY,this.rocks.length===0)for(let s=0;s<t.spawnCount;s++)this.spawnRock()}setMovement(t,s){t!==void 0&&(this.hero.vx=t),s!==void 0&&(this.hero.vy=s)}modifyHp(t){this.hero.hp=Math.max(0,Math.min(100,this.hero.hp+t)),t<0&&this.triggerHitCooldown()}triggerHitCooldown(){this.lastHitFrame=this.currentFrame}destroy(){super.destroy(),this.rocks=[]}getSnapshot(){return{hero:{...this.hero},rocks:[...this.rocks],lastHitFrame:this.lastHitFrame,currentFrame:this.currentFrame,config:this.config}}loadSnapshot(t){t&&(this.config=t.config,this.hero=t.hero,this.rocks=t.rocks,this.lastHitFrame=t.lastHitFrame,this.currentFrame=t.currentFrame??0,this.isInitialized=!0)}onUpdate(t,s,e,o){if(!this.config)return;this.currentFrame=e;const i=this.inputState.actions,r=this.config.moveSpeed;let a=0,c=0;i.includes("MOVE_UP")&&(c=-r),i.includes("MOVE_DOWN")&&(c=r),i.includes("MOVE_LEFT")&&(a=-r),i.includes("MOVE_RIGHT")&&(a=r),this.setMovement(a,c),this.currentFrame-this.lastHitFrame>120&&this.hero.hp<100&&(this.hero.hp=Math.min(100,this.hero.hp+(this.hero.hp<25?.3:.1))),this.hero.x=Math.max(0,Math.min(this.config.width,this.hero.x+this.hero.vx)),this.hero.y=Math.max(0,Math.min(this.config.height,this.hero.y+this.hero.vy)),this.processRocks(e),this.processRockAttacks(e),this.syncToSAB(t,e,o)}spawnRock(){!this.config||this.rocks.length>=l.MAX_ROCKS||this.rocks.push({x:Math.random()*this.config.width,y:.1*this.config.height,vx:0,vy:0,timeElapsed:Date.now()+Math.random()*1e3,seed:Math.random()*1e3,atkBox:{sX:0,sY:0,eX:0,eY:0},followRun:!1,primedMode:!1})}processRocks(t){if(this.config)for(let s=this.rocks.length-1;s>=0;s--){const e=this.rocks[s];if(e.primedMode)continue;const o=e.x-this.hero.x,i=e.y-this.hero.y,r=o*o+i*i,a=Math.sqrt(o*o+i*i);e.followRun?(e.vx*=0,e.vy*=0):(e.vx=this.getSnapshot().config.moveSpeed-1,e.vy=this.getSnapshot().config.moveSpeed-1,a>200&&(e.vx*=o>0?-1:1,e.vy*=i>0?-1:1),a<250&&(e.vx*=o>0?1:-1,e.vy*=i>0?1:-1)),e.vx=e.x<=0?1:e.vx,e.vx=e.x>=this.config.width?-1:e.vx,e.vy=e.y<=0?1:e.vy,e.vy=e.y>=this.config.height?-1:e.vy,e.x+=e.vx,e.y+=e.vy,e.followRun=a>200&&a<250,r<1600&&(e.vx*=-1.1,e.vy*=-1.1,this.modifyHp(-.2),self.postMessage({type:"EVENT",name:"EXPLOSION_REQ"}))}}processRockAttacks(t){if(this.config)for(let s=this.rocks.length-1;s>=0;s--){const e=this.rocks[s],o=Date.now()-e.timeElapsed;if(o>5e3&&!e.primedMode&&(e.primedMode=!0,e.atkBox={sX:e.x,sY:e.y,eX:this.hero.x,eY:this.hero.y}),e.primedMode&&o>7e3){const i=(e.atkBox.eY-e.atkBox.sY)/(e.atkBox.eX-e.atkBox.sX),r=e.atkBox.sY-i*e.atkBox.sX,a=Math.abs(i*this.hero.x+-1*this.hero.y+r),c=Math.sqrt(i*i+1);a/c<30&&this.modifyHp(-10),e.timeElapsed=Date.now(),e.primedMode=!1,e.atkBox={sX:0,sY:0,eX:0,eY:0}}}}syncToSAB(t,s,e){t[l.HERO_HP]=this.hero.hp,t[l.HERO_X]=this.hero.x,t[l.HERO_Y]=this.hero.y,t[l.ENTITY_COUNT]=this.rocks.length,this.rocks.forEach((o,i)=>{const r=l.ROCKS_START_INDEX+i*l.ROCK_STRIDE;t[r]=o.x,t[r+1]=o.y,t[r+2]=o.seed,t[r+3]=o.primedMode?1:0,t[r+4]=o.atkBox.sX,t[r+5]=o.atkBox.sY,t[r+6]=o.atkBox.eX,t[r+7]=o.atkBox.eY})}}const u=new Map,y=new Map,w=new Map,f=new Map;self.onmessage=n=>{const{type:t,stateName:s,payload:e,frameCount:o,fps:i}=n.data;switch(t){case"INIT_SABS":console.log("[Worker] Initializing Buffer Map"),u.clear(),y.clear(),w.clear(),e.buffers&&Object.entries(e.buffers).forEach(([h,p])=>{u.set(h,p),y.set(h,new Float32Array(p)),w.set(h,new Int32Array(p))}),f.forEach((h,p)=>{if(typeof h.setBuffers=="function"){const m={};u.forEach((x,_)=>m[_]=x),h.setBuffers(m)}});break;case"UPDATE_BUFFER":const{name:r,buffer:a}=e;u.set(r,a),y.set(r,new Float32Array(a)),w.set(r,new Int32Array(a)),f.forEach(h=>{if(typeof h.setBuffers=="function"){console.log(`[Worker] Updating buffer views for existing state: ${r}`);const p={};u.forEach((m,x)=>p[x]=m),h.setBuffers(p)}});break;case"CREATE_STATE":if(e?.force&&f.has(s)&&(console.warn(`[Worker] Force-recreating state: ${s}`),f.get(s).destroy(),f.delete(s)),!f.has(s)){console.log(`[Worker] Created Logic for: ${s}`);let h;if(s==="Game1"&&(h=new I),s==="Game2"&&(h=new T),s==="BHTest"&&(h=new O),h){if(f.set(s,h),u.size>0){const p={};u.forEach((m,x)=>p[x]=m),h.setBuffers(p)}}else console.error(`[Worker] Failed to create logic instance for: ${s}`)}break;case"TERMINATE_STATE":f.has(s)?(console.log(`[Worker] Terminated Logic for: ${s}`),f.get(s).destroy(),f.delete(s)):console.warn(`[Worker] Attempted to terminate non-existent state: ${s}`);break;case"TERMINATE_ALL":console.log(`[Worker] Terminating all logic states. Count: ${f.size}`),f.forEach(h=>h.destroy()),f.clear();break;case"INPUT":const c=f.get(s);if(c)if(e.action==="GET_SNAPSHOT"){console.info(`[Worker] [${s}] Generating Snapshot`);const h=n.ports[0];h&&h.postMessage(c.getSnapshot())}else e.action==="LOAD_SNAPSHOT"?(console.info(`[Worker] [${s}] Loading Snapshot`),c.loadSnapshot(e.data)):(console.debug(`[Worker] [${s}] Input: ${e.action||"Unknown Action"}`),c.handleInput(e));else console.error(`[Worker] Received INPUT for unknown state: ${s}`);break;case"TICK":const E=f.get(s);E&&y.size>0&&E.update(y,w,o,i);break;default:console.warn(`[Worker] Unhandled message type: ${t}`);break}}})();
