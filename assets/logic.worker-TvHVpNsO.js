(function(){"use strict";class N{definitions=new Map;register(t){this.definitions.set(t.id,t)}create(t){const i=this.definitions.get(t);if(!i)throw new Error(`WorkerRegistry: No factory registered for ID "${t}"`);return i.factory()}}const T=new N,x=new N;var E=(o=>(o.GAME_1="Game1",o.GAME_2="Game2",o.GAME_3="Game3",o.BH_GAME="BHGame",o.DEV_MENU="DevMenu",o.PAUSE_MENU="PauseMenu",o.SAVE_MENU="SaveMenu",o.SETTINGS_MENU="SettingsMenu",o.CONTINUE="ContinueScreen",o.GAME_OVER="GameOverScreen",o))(E||{});const d={HERO_HP:0,HERO_X:1,HERO_Y:2,REVISION:6,ENTITY_COUNT:8},O={STRIDE:3};class I{constructor(t){this.revisionIndex=t}isInitialized=!1;sharedViews=new Map;intViews=new Map;config=null;inputState={actions:[],mouseX:0,mouseY:0,isMouseDown:!1,isHovering:!1};setBuffers(t){this.sharedViews.clear(),this.intViews.clear(),Object.entries(t).forEach(([i,e])=>{this.sharedViews.set(i,new Float32Array(e)),this.intViews.set(i,new Int32Array(e))})}get sharedView(){const t=this.sharedViews.get("main")||this.sharedViews.values().next().value;if(!t)throw new Error(`[BaseLogic] No SharedView available for ${this.constructor.name}`);return t}get intView(){const t=this.intViews.get("main")||this.intViews.values().next().value;if(!t)throw new Error(`[BaseLogic] No IntView available for ${this.constructor.name}`);return t}setInitialized(t){this.isInitialized=t,t&&this.onInitialize()}update(t,i,e,s){if(!this.isInitialized||this.sharedViews.size===0)return;this.onUpdate(this.sharedView,this.intView,e,s);const h=this.intView;h&&Atomics.add(h,this.revisionIndex,1)}handleInput(t){if(t.action==="SYNC_INPUT"){this.inputState.actions=t.actions||[],this.inputState.mouseX=t.mouseX||0,this.inputState.mouseY=t.mouseY||0,this.inputState.isMouseDown=!!t.isMouseDown,this.inputState.isHovering=!!t.isHovering;return}this.dispatcher.dispatch(t.action,t)}destroy(){this.isInitialized=!1,this.config=null}getSnapshot(){return{}}loadSnapshot(t){}onInitialize(){}}class M{constructor(t,i,e="Dispatcher"){this.logic=t,this.commands=i,this.debugName=e}dispatch(t,i){const e=this.commands[t];e?e.execute(this.logic,i):console.warn(`[${this.debugName}] Unknown action: ${t}`)}}const D={INITIALIZE:{execute(o,t){o.applyConfig(t),o.setInitialized(!0)}},MOVEMENT:{execute(o,t){o.setMovement(t.vx,t.vy)}},TAKE_DAMAGE:{execute(o,t){const i=t.amount??15;o.modifyHp(-i)}}};class F extends I{dispatcher;hero={x:0,y:0,vx:0,vy:0,hp:100};rocks=[];currentFrame=0;lastHitFrame=0;wasMouseDown=!1;constructor(){super(d.REVISION),this.dispatcher=new M(this,D,"Game1")}applyConfig(t){if(this.config=t,this.hero.hp=t.initialHP,this.hero.x=t.heroStartX,this.hero.y=t.heroStartY,this.rocks.length===0)for(let i=0;i<t.spawnCount;i++)this.spawnRock()}setMovement(t,i){t!==void 0&&(this.hero.vx=t),i!==void 0&&(this.hero.vy=i)}modifyHp(t){this.hero.hp=Math.max(0,Math.min(100,this.hero.hp+t)),t<0&&this.triggerHitCooldown()}triggerHitCooldown(){this.lastHitFrame=this.currentFrame}destroy(){super.destroy(),this.rocks=[]}getSnapshot(){return{hero:{...this.hero},rocks:[...this.rocks],lastHitFrame:this.lastHitFrame,currentFrame:this.currentFrame,config:this.config}}loadSnapshot(t){t&&(this.config=t.config,this.hero=t.hero,this.rocks=t.rocks,this.lastHitFrame=t.lastHitFrame,this.currentFrame=t.currentFrame??0,this.isInitialized=!0)}onUpdate(t,i,e,s){if(!this.config)return;this.currentFrame=e;const h=this.inputState.actions,r=this.config.moveSpeed;let c=0,a=0;if(h.includes("MOVE_UP")&&(a=-r),h.includes("MOVE_DOWN")&&(a=r),h.includes("MOVE_LEFT")&&(c=-r),h.includes("MOVE_RIGHT")&&(c=r),this.setMovement(c,a),this.inputState.isMouseDown&&!this.wasMouseDown){const p=this.inputState.mouseX*this.config.width,n=this.inputState.mouseY*this.config.height;this.spawnRock(p,n)}this.wasMouseDown=this.inputState.isMouseDown,this.currentFrame-this.lastHitFrame>120&&this.hero.hp<100&&(this.hero.hp=Math.min(100,this.hero.hp+(this.hero.hp<25?.3:.1))),this.hero.x=Math.max(0,Math.min(this.config.width,this.hero.x+this.hero.vx)),this.hero.y=Math.max(0,Math.min(this.config.height,this.hero.y+this.hero.vy)),this.processRocks(e),this.syncToSAB(t,e,s)}spawnRock(t,i){if(!this.config)return;const e=this.sharedViews.get("rocks");if(!e)return;const s=Math.floor(e.length/O.STRIDE);if(this.rocks.length>=s){const h=e.length+1e3*O.STRIDE;this._resizeRequested!==h&&(console.log(`[Game1Logic] Requesting Resize. Current: ${e.length}, New: ${h}`),self.postMessage({type:"REQUEST_RESIZE",payload:{bufferName:"rocks",newSize:h}}),this._resizeRequested=h);return}this._resizeRequested=0,this.rocks.push({x:t??Math.random()*this.config.width,y:i??Math.random()*this.config.height,vx:(Math.random()-.5)*8,vy:(Math.random()-.5)*8,seed:Math.random()*1e3})}processRocks(t){if(this.config)for(let i=this.rocks.length-1;i>=0;i--){const e=this.rocks[i];e.x+=e.vx,e.y+=e.vy;let s=!1;(e.x<=0||e.x>=this.config.width)&&(e.vx*=-1,s=!0),(e.y<=0||e.y>=this.config.height)&&(e.vy*=-1,s=!0);const h=e.x-this.hero.x,r=e.y-this.hero.y;h*h+r*r<1600&&(e.vx*=-1.1,e.vy*=-1.1,this.modifyHp(-.2),s=!0,self.postMessage({type:"EVENT",name:"EXPLOSION_REQ"})),s&&Math.random()>.8&&this.spawnRock()}}syncToSAB(t,i,e){const s=this.sharedViews.get("main"),h=this.sharedViews.get("rocks");s&&(s[d.HERO_HP]=this.hero.hp,s[d.HERO_X]=this.hero.x,s[d.HERO_Y]=this.hero.y,s[d.ENTITY_COUNT]=this.rocks.length),h&&this.rocks.forEach((r,c)=>{const a=c*O.STRIDE;a+2<h.length&&(h[a]=r.x,h[a+1]=r.y,h[a+2]=r.seed)})}}const y={HERO_HP:0,ENERGY:1,SCRAP_COUNT:2,TICK_COUNT:3,REVISION:6},L={INITIALIZE:{execute(o,t){o.applyConfig(t),o.setInitialized(!0)}},MOD_HP:{execute(o,t){o.modifyHp(t.amount)}},MOD_ENERGY:{execute(o,t){o.modifyEnergy(t.amount)}},ADD_SCRAP:{execute(o){o.addScrap(1)}}};class G extends I{dispatcher;hp=100;energy=50;scrap=0;currentFrame=0;constructor(){super(y.REVISION),this.dispatcher=new M(this,L,"Game2")}applyConfig(t){this.config=t,this.hp=t.initialHP,this.energy=t.initialEnergy,this.scrap=t.initialScrap}modifyHp(t){this.hp=Math.max(0,this.hp+t)}modifyEnergy(t){this.config&&(this.energy=Math.max(0,this.energy+t))}addScrap(t=1){this.scrap+=t}destroy(){super.destroy(),this.hp=100,this.energy=50,this.scrap=0}getSnapshot(){return{hp:this.hp,energy:this.energy,scrap:this.scrap,currentFrame:this.currentFrame,config:this.config}}loadSnapshot(t){t&&(this.config=t.config,this.hp=t.hp??100,this.energy=t.energy??50,this.scrap=t.scrap??0,this.isInitialized=!0)}onUpdate(t,i,e,s){this.config&&(this.currentFrame=e,e%this.config.regenRate===0&&this.energy<this.config.maxEnergy&&this.modifyEnergy(1),t[y.HERO_HP]=this.hp,t[y.ENERGY]=this.energy,t[y.SCRAP_COUNT]=this.scrap,t[y.TICK_COUNT]=e)}}const w={HERO_X:0,HERO_Y:1,HERO_ROTATION:2,HERO_SCALE:3,HERO_HP_DISPLAY:4,HERO_FRAME:5,ACTIVE_ROCK_COUNT:6},k={STRIDE:3};class P{logicViews=new Map;logicIntViews=new Map;outputViews=new Map;setBuffers(t,i,e){this.logicViews=t,this.logicIntViews=i,this.outputViews=e}get logicView(){return(this.logicViews.get("main")||this.logicViews.values().next().value)??new Float32Array(0)}get logicIntView(){return(this.logicIntViews.get("main")||this.logicIntViews.values().next().value)??new Int32Array(0)}get outputView(){return(this.outputViews.get("main")||this.outputViews.values().next().value)??new Float32Array(0)}getSnapshot(){return{}}loadSnapshot(t){}destroy(){}hasBuffers(){return this.logicViews.size>0&&this.outputViews.size>0}}class Y extends P{heroRotation=0;globalRockRotation=0;heroFrame=0;update(t,i){const e=this.logicViews.get("main"),s=this.logicViews.get("rocks"),h=this.outputViews.get("main"),r=this.outputViews.get("rocks");if(!e||!s||!h||!r)return;const c=e[d.ENTITY_COUNT],a=Math.floor(r.length/k.STRIDE);c>a?this._outResizePending!==a&&(self.postMessage({type:"REQUEST_RESIZE_OUTPUT",payload:{bufferName:"rocks",newSize:(c+1e3)*k.STRIDE}}),this._outResizePending=a):this._outResizePending=0;const p=e[d.HERO_HP];this.heroRotation+=.03*(t/16.67),this.heroFrame+=.15*(t/16.67),h[w.HERO_X]=e[d.HERO_X],h[w.HERO_Y]=e[d.HERO_Y],h[w.HERO_ROTATION]=this.heroRotation,h[w.HERO_SCALE]=.5+p/100,h[w.HERO_HP_DISPLAY]=p,h[w.HERO_FRAME]=this.heroFrame;const n=Math.min(c,a);h[w.ACTIVE_ROCK_COUNT]=n,this.globalRockRotation+=.02*(t/16.67);for(let u=0;u<n;u++){const f=u*O.STRIDE,R=u*k.STRIDE;if(f+2>=s.length)break;r[R]=s[f],r[R+1]=s[f+1];const V=s[f+2],Q=(Math.floor(V)%5+1)*.5;r[R+2]=this.globalRockRotation*Q+V}}getSnapshot(){return{heroRotation:this.heroRotation,globalRockRotation:this.globalRockRotation,heroFrame:this.heroFrame}}loadSnapshot(t){t&&(this.heroRotation=t.heroRotation??0,this.globalRockRotation=t.globalRockRotation??0,this.heroFrame=t.heroFrame??0)}}const _={HERO_HP_DISPLAY:0,ENERGY_DISPLAY:1,SCRAP_DISPLAY:2,UI_BOUNCE:3,GLITCH_INTENSITY:4,VIGNETTE_PULSE:5};class B extends P{uiBounce=0;glitchIntensity=0;lastHp=-1;update(t,i){if(!this.hasBuffers())return;const e=this.logicView[y.HERO_HP],s=this.logicView[y.ENERGY];this.lastHp!==-1&&e<this.lastHp&&(this.glitchIntensity=1),this.lastHp=e,this.glitchIntensity*=.92,this.outputView[_.HERO_HP_DISPLAY]=e,this.outputView[_.ENERGY_DISPLAY]=s,this.outputView[_.SCRAP_DISPLAY]=this.logicView[y.SCRAP_COUNT];const h=t/16.67;this.uiBounce+=.05*h;const r=s<20?.15:.05,c=.5+Math.sin(i*r)*.2;this.outputView[_.UI_BOUNCE]=Math.sin(this.uiBounce)*5,this.outputView[_.GLITCH_INTENSITY]=this.glitchIntensity,this.outputView[_.VIGNETTE_PULSE]=c}getSnapshot(){return{uiBounce:this.uiBounce,glitchIntensity:this.glitchIntensity,lastHp:this.lastHp}}loadSnapshot(t){t&&(this.uiBounce=t.uiBounce??0,this.glitchIntensity=t.glitchIntensity??0,this.lastHp=t.lastHp??-1)}}const l={HERO_HP:0,HERO_X:1,HERO_Y:2,REVISION:6,ENTITY_COUNT:8,ROCKS_START_INDEX:10,PPROJ_START_INDEX:75,PPROJ_STRIDE:2,ROCK_STRIDE:6,MAX_ROCKS:1e3},X={INITIALIZE:{execute(o,t){o.applyConfig(t),o.setInitialized(!0)}},MOVEMENT:{execute(o,t){o.setMovement(t.vx,t.vy)}},TAKE_DAMAGE:{execute(o,t){const i=t.amount??15;o.modifyHp(-i)}}};class U{seed;height;width;x;y;vx;vy;damage;active;hitbox;playerRelative;constructor(t,i){this.x=t,this.y=i,this.vx=0,this.vy=0,this.damage=0,this.height=0,this.width=0,this.seed=Math.random()*1e3,this.active=!1,this.hitbox={offsetX:0,offsetY:0},this.playerRelative=0}collided(t){for(const i of t){if(!this.active)break;i.active&&(this.x<i.x+i.width&&this.x+this.width>i.x&&this.y<i.y+i.height&&this.y+this.height>i.y&&(i.modifyHP(this.damage),this.active=!1),i.health<=0&&(i.active=!1))}}}class W extends U{speed=8;constructor(t,i,e,s){super(t,i),this.active=!0;const h=s.width*e.mouseX-this.x,r=s.height*e.mouseY-this.y;this.playerRelative=Math.atan2(r,h),this.vx=Math.cos(this.playerRelative)*this.speed,this.vy=Math.sin(this.playerRelative)*this.speed,this.damage=-20,this.height=20,this.width=20}update(t,i){this.x+=this.vx,this.y+=this.vy,(this.x<0||this.x>i.width||this.y<0||this.y>i.height)&&(this.active=!1)}syncToSAB(t,i){t[i]=this.x,t[i+1]=this.y}}class H{static instance;active;height;hitbox;hp;moveSpeed;vx;vy;width;seed;playerRelative;x;y;currentFrame=0;lastHitFrame=0;bulletTime=Date.now();fireFlag=!1;config;constructor(){this.active=!0,this.x=0,this.y=0,this.vx=0,this.vy=0,this.playerRelative=0,this.hitbox={offsetX:0,offsetY:0},this.height=0,this.width=0,this.hp=100,this.moveSpeed=0,this.seed=Math.random()*1e3}static getInstance(){return H.instance||(H.instance=new H),H.instance}applyConfig(t){this.config=t,this.hp=t.initialHP,this.x=t.heroStartX,this.y=t.heroStartY,this.moveSpeed=t.moveSpeed}setMovement(t,i){t!==void 0&&(this.vx=t),i!==void 0&&(this.vy=i)}modifyHp(t){this.hp=Math.max(0,Math.min(100,this.hp+t)),t<0&&this.triggerHitCooldown()}triggerHitCooldown(){this.lastHitFrame=this.currentFrame}playerAction(){const t=this.fireFlag;return this.fireFlag=!1,t}fireProjectile(t,i){return new W(this.x,this.y,t,i)}updatePlayer(t,i,e){this.currentFrame=e,this.update(t,i)}update(t,i){const e=t.actions;if(e===void 0)return;let s=0,h=0;e.includes("MOVE_UP")&&(h=-this.moveSpeed),e.includes("MOVE_DOWN")&&(h=this.moveSpeed),e.includes("MOVE_LEFT")&&(s=-this.moveSpeed),e.includes("MOVE_RIGHT")&&(s=this.moveSpeed),t.isMouseDown&&this.bulletTime+250<Date.now()&&(this.bulletTime=Date.now(),this.fireFlag=!0),this.setMovement(s,h),this.currentFrame-this.lastHitFrame>120&&this.hp<100&&(this.hp=Math.min(100,this.hp+(this.hp<25?.3:.1))),this.x=Math.max(0,Math.min(this.config.width,this.x+this.vx)),this.y=Math.max(0,Math.min(this.config.height,this.y+this.vy))}}class b{active;height;playerRelative;hitbox;seed;width;health;x;y;vx;vy;constructor(){this.x=0,this.y=0,this.vx=0,this.vy=0,this.health=0,this.hitbox={offsetX:0,offsetY:0},this.height=0,this.width=0,this.seed=Math.random()*1e3,this.active=!1,this.playerRelative=0}modifyHP(t){this.active&&(this.health+=t),this.health<0&&(this.active=!1)}}class J extends b{timeElapsed;atkBox;followRun;primedMode;constructor(t,i){super(),this.x=t,this.y=i,this.width=50,this.height=52,this.health=100,this.timeElapsed=Date.now()+Math.random()*1e3,this.atkBox={eX:0,eY:0},this.followRun=!1,this.primedMode=!1,this.active=!0}update(t,i){this.orientation(t),this.processRock(t,i),this.processRockAttacks(t,i)}orientation(t){const i=this.x-t.x,e=this.y-t.y;this.playerRelative=Math.atan2(e,i)}syncToSAB(t,i){t[i]=this.x,t[i+1]=this.y,t[i+2]=this.seed,t[i+3]=this.primedMode?1:0,t[i+4]=this.atkBox.eX,t[i+5]=this.atkBox.eY}processRock(t,i){if(this.primedMode)return;const e=this.x-t.x,s=this.y-t.y,h=e*e+s*s,r=Math.sqrt(e*e+s*s);this.followRun?(this.vx*=0,this.vy*=0):(this.vx=i.moveSpeed-1,this.vy=i.moveSpeed-1,r>200&&(this.vx*=e>0?-1:1,this.vy*=s>0?-1:1),r<250&&(this.vx*=e>0?1:-1,this.vy*=s>0?1:-1)),this.vx=this.x<=0?1:this.vx,this.vx=this.x>=i.width?-1:this.vx,this.vy=this.y<=0?1:this.vy,this.vy=this.y>=i.height?-1:this.vy,this.x+=this.vx,this.y+=this.vy,this.followRun=r>200&&r<250,h<1600&&(this.vx*=-1.1,this.vy*=-1.1,t.modifyHp(-.2),self.postMessage({type:"EVENT",name:"EXPLOSION_REQ"}))}processRockAttacks(t,i){const e=Date.now()-this.timeElapsed;if(e>5e3&&!this.primedMode&&(this.primedMode=!0,this.atkBox={eX:t.x,eY:t.y}),this.primedMode&&e>7e3){const s=(this.atkBox.eY-this.y)/(this.atkBox.eX-this.x),h=this.y-s*this.x,r=Math.abs(s*t.x+-1*t.y+h),c=Math.sqrt(s*s+1);r/c<30&&Math.min(this.atkBox.eX,this.x)<=t.x&&t.x<=Math.max(this.atkBox.eX,this.x)&&Math.min(this.atkBox.eY,this.y)<=t.y&&t.y<=Math.max(this.atkBox.eY,this.y)&&t.modifyHp(-10),this.timeElapsed=Date.now(),this.primedMode=!1,this.atkBox={eX:0,eY:0}}}}class z extends I{dispatcher;player;entities=[];playerProjectiles=[];evilProjectils=[];currentFrame=0;constructor(){super(l.REVISION),this.dispatcher=new M(this,X,"BHTest"),this.player=H.getInstance()}applyConfig(t){if(this.config=t,this.player.applyConfig(t),this.entities.length===0)for(let i=0;i<t.spawnCount;i++)this.spawnEntities()}destroy(){super.destroy(),this.entities=[],this.playerProjectiles=[],this.evilProjectils=[]}getSnapshot(){return{player:{...this.player},entities:[...this.entities],playerProjectiles:[...this.playerProjectiles],evilProjectils:[...this.evilProjectils],currentFrame:this.currentFrame,config:this.config}}loadSnapshot(t){t&&(this.config=t.config,this.player=t.player,this.entities=t.entities,this.playerProjectiles=t.playerProjectiles,this.evilProjectils=t.evilProjectils,this.currentFrame=t.currentFrame??0,this.isInitialized=!0)}onUpdate(t,i,e,s){if(this.config){this.currentFrame=e,this.player.updatePlayer(this.inputState,this.config,e);for(const h of this.entities)h.update(this.player,this.config);this.player.playerAction()&&this.playerProjectiles.push(this.player.fireProjectile(this.inputState,this.config));for(const h of this.playerProjectiles)h.update(this.player,this.config),h.collided(this.entities);this.playerProjectiles=this.playerProjectiles.filter(h=>h.active),this.entities=this.entities.filter(h=>h.active),this.syncToSAB(t,e,s)}}spawnEntities(){!this.config||this.entities.length>=l.MAX_ROCKS||this.entities.push(new J(Math.random()*this.config.width,.1*this.config.height))}syncToSAB(t,i,e){t[l.HERO_HP]=this.player.hp,t[l.HERO_X]=this.player.x,t[l.HERO_Y]=this.player.y,t[l.ENTITY_COUNT]=this.entities.length,this.entities.forEach((s,h)=>{const r=l.ROCKS_START_INDEX+h*l.ROCK_STRIDE;s.syncToSAB(t,r)}),t[l.PPROJ_START_INDEX-1]=this.playerProjectiles.length,this.playerProjectiles.forEach((s,h)=>{const r=l.PPROJ_START_INDEX+h*l.PPROJ_STRIDE;s.syncToSAB(t,r)})}}const g={HERO_X:0,HERO_Y:1,HERO_ROTATION:2,HERO_SCALE:3,HERO_HP_DISPLAY:4,HERO_FRAME:5,ACTIVE_ROCK_COUNT:8,ROCKS_START_INDEX:10,ROCK_STRIDE:6,PPROJ_START_INDEX:75,PPROJ_STRIDE:2};class j extends P{heroRotation=0;globalRockRotation=0;heroFrame=0;update(t,i){if(!this.hasBuffers())return;const e=this.logicView[l.HERO_X],s=this.logicView[l.HERO_Y],h=this.logicView[l.HERO_HP];this.heroRotation+=.03*(t/16.67),this.heroFrame+=.15*(t/16.67),this.outputView[g.HERO_X]=e,this.outputView[g.HERO_Y]=s,this.outputView[g.HERO_ROTATION]=this.heroRotation,this.outputView[g.HERO_SCALE]=.5+h/100,this.outputView[g.HERO_HP_DISPLAY]=h,this.outputView[g.HERO_FRAME]=this.heroFrame;const r=this.logicView[l.ENTITY_COUNT];this.outputView[g.ACTIVE_ROCK_COUNT]=r,this.globalRockRotation+=.02*(t/16.67);for(let a=0;a<r;a++){const p=l.ROCKS_START_INDEX+a*l.ROCK_STRIDE,n=g.ROCKS_START_INDEX+a*g.ROCK_STRIDE;this.outputView[n]=this.logicView[p],this.outputView[n+1]=this.logicView[p+1];const u=this.logicView[p+2],f=(Math.floor(u)%5+1)*.5;this.outputView[n+2]=this.globalRockRotation*f+u,this.outputView[n+3]=this.logicView[p+3],this.outputView[n+4]=this.logicView[p+4],this.outputView[n+5]=this.logicView[p+5],this.outputView[n+6]=this.logicView[p+6],this.outputView[n+7]=this.logicView[p+7]}const c=this.logicView[l.PPROJ_START_INDEX-1];this.outputView[l.PPROJ_START_INDEX-1]=c;for(let a=0;a<c;a++){const p=l.PPROJ_START_INDEX+a*l.PPROJ_STRIDE,n=g.PPROJ_START_INDEX+a*g.PPROJ_STRIDE;this.outputView[n]=this.logicView[p],this.outputView[n+1]=this.logicView[p+1]}}getSnapshot(){return{heroRotation:this.heroRotation,globalRockRotation:this.globalRockRotation,heroFrame:this.heroFrame}}loadSnapshot(t){t&&(this.heroRotation=t.heroRotation??0,this.globalRockRotation=t.globalRockRotation??0,this.heroFrame=t.heroFrame??0)}}const C={REVISION:0,FRAME_COUNT:1,FPS:2,HERO_X:10,HERO_Y:11,HERO_VX:12,HERO_VY:13,HERO_HP:14,HERO_WIDTH:20,HERO_HEIGHT:21,HERO_FLIP:22,HERO_ANIM_STATE:23,HERO_ANIM_FRAME:24,WORLD_SCALE:30,PLAYER_SCALE:31,PLAYER_OFFSET_Y:32},K={INITIALIZE:{execute(o,t){o.applyConfig(t),t.mapPath||o.setInitialized(!0)}},SET_MAP_DATA:{execute(o,t){o.setMapData(t),o.setInitialized(!0)}},MOD_HP:{execute(o,t){o.modifyHP(t.amount)}}};class $ extends I{dispatcher;hp=100;hero={x:0,y:0,vx:0,vy:0};isOnGround=!1;isWallSliding=!1;wallJumpTimer=0;wallJumpDirection=0;spikeDamageTimer=0;wasInSpike=!1;portalCooldown=0;isJumpingFromGround=!1;hasCompletedLevel=!1;spawnPoint={x:0,y:0};animFrame=0;animTimer=0;flipX=!1;animState=0;heroWidth=1;heroHeight=1;worldScale=32;playerScale=1;playerOffsetY=0;platforms=[];moveSpeed=.2;jumpPower=-.4;gravity=.04;friction=.5;constructor(){super(C.REVISION),this.dispatcher=new M(this,K,"Game3")}applyConfig(t){this.config=t,this.hp=t.initialHP,this.worldScale=t.worldScale||32,this.playerScale=t.playerScale||1,this.playerOffsetY=t.playerOffsetY||0,this.heroWidth=t.heroWidth||1,this.heroHeight=t.heroHeight||2,this.moveSpeed=.2,this.jumpPower=-.4,this.gravity=.04}setMapData(t){this.platforms=t.platforms,this.hero.x=t.playerStart.x,this.hero.y=t.playerStart.y,this.spawnPoint={x:t.playerStart.x,y:t.playerStart.y},this.hero.vx=0,this.hero.vy=0,this.hasCompletedLevel=!1,t.playerStart.width&&t.playerStart.height&&(this.heroWidth=t.playerStart.width,this.heroHeight=t.playerStart.height)}onUpdate(t,i,e,s){!this.config||!this.isInitialized||(this.isOnGround=this.checkIsOnGround(),this.updateHeroMovement(),this.resolveMovement(),this.updateAnimation(),this.updateExitLogic(),this.updateSpikeLogic(),this.updatePortalLogic(),this.updateVoidLogic(),this.syncToSAB(t,e,s))}isAction(t){return this.inputState&&this.inputState.actions&&this.inputState.actions.includes(t)}checkIsOnGround(){const t=this.hero.y+this.heroHeight+.1;for(const i of this.platforms)if(!(i.isSpike||i.isPortal||i.isVoid||i.isExit)&&this.hero.x+this.heroWidth>i.x&&this.hero.x<i.x+i.width&&t>i.y&&this.hero.y+this.heroHeight<=i.y)return!0;return!1}getWallCollision(){for(const i of this.platforms)if(i.isWall&&this.hero.x<=i.x+i.width&&this.hero.x+.1>i.x+i.width&&this.hero.y+this.heroHeight>i.y&&this.hero.y<i.y+i.height)return-1;for(const i of this.platforms)if(i.isWall&&this.hero.x+this.heroWidth>=i.x&&this.hero.x+this.heroWidth-.1<i.x&&this.hero.y+this.heroHeight>i.y&&this.hero.y<i.y+i.height)return 1;return 0}updateHeroMovement(){const t=this.getWallCollision(),i=this.isAction("MOVE_LEFT"),e=this.isAction("MOVE_RIGHT"),s=this.isAction("JUMP");let h=0;i&&(h-=1),e&&(h+=1),this.wallJumpTimer>0?(this.hero.vx=this.wallJumpDirection*this.moveSpeed*1.5,this.wallJumpTimer--,t!==0&&this.wallJumpDirection):h!==0?this.hero.vx=h*this.moveSpeed:(this.hero.vx*=this.friction,Math.abs(this.hero.vx)<.01&&(this.hero.vx=0)),this.isWallSliding=!1,!this.isOnGround&&t!==0&&(t===-1&&h===-1||t===1&&h===1)&&(this.isWallSliding=!0,this.wallJumpTimer=0);let r=this.gravity;this.isJumpingFromGround&&s&&this.hero.vy<0&&(r*=.5),this.isWallSliding&&this.hero.vy>0?(this.hero.vy+=r*.2,this.hero.vy>.1&&(this.hero.vy=.1)):this.hero.vy+=r,s&&(this.isOnGround?(this.hero.vy=this.jumpPower,this.wallJumpTimer=0,this.isJumpingFromGround=!0):t!==0&&(s||this.isWallSliding)&&(this.hero.vy=this.jumpPower,this.wallJumpDirection=-t,this.wallJumpTimer=15,this.isWallSliding=!1,this.isJumpingFromGround=!1)),this.hero.vy>=0&&(this.isJumpingFromGround=!1),this.hero.vy>.8&&(this.hero.vy=.8)}updateSpikeLogic(){const t=this.checkHazardCollision("isSpike");t&&(!this.wasInSpike||this.spikeDamageTimer<=0)&&(this.modifyHP(-10),this.spikeDamageTimer=120),this.spikeDamageTimer>0&&this.spikeDamageTimer--,this.wasInSpike=t}updatePortalLogic(){if(this.portalCooldown>0){this.portalCooldown--;return}const t=this.getCollidingPlatform("isPortal");if(t){const i=this.platforms.filter(e=>e.isPortal);if(i.length>=2){const e=i.find(s=>s!==t);e&&(this.hero.x=e.x+e.width/2-this.heroWidth/2,this.hero.y=e.y+e.height/2-this.heroHeight/2,this.portalCooldown=60)}}}updateVoidLogic(){this.checkHazardCollision("isVoid")&&(this.hero.x=this.spawnPoint.x,this.hero.y=this.spawnPoint.y,this.hero.vx=0,this.hero.vy=0,this.modifyHP(-20))}updateExitLogic(){!this.hasCompletedLevel&&this.checkHazardCollision("isExit")&&(this.hasCompletedLevel=!0,this.dispatcher.dispatch("LEVEL_COMPLETE",{}))}checkHazardCollision(t){return!!this.getCollidingPlatform(t)}getCollidingPlatform(t){for(const e of this.platforms)if(e[t]&&this.hero.x+this.heroWidth-.05>e.x&&this.hero.x+.05<e.x+e.width&&this.hero.y+this.heroHeight-.05>e.y&&this.hero.y+.05<e.y+e.height)return e}resolveMovement(){const t=this.hero.x+this.hero.vx;for(const s of this.platforms)if(!(s.isSpike||s.isPortal||s.isVoid||s.isExit)&&t+this.heroWidth>s.x&&t<s.x+s.width&&this.hero.y+this.heroHeight>s.y&&this.hero.y<s.y+s.height){t>this.hero.x?this.hero.x=s.x-this.heroWidth:t<this.hero.x&&(this.hero.x=s.x+s.width),this.hero.vx=0;break}this.hero.vx!==0&&(this.hero.x=t);const i=this.hero.y+this.hero.vy;let e=!1;for(const s of this.platforms)if(!(s.isSpike||s.isPortal||s.isVoid||s.isExit)&&this.hero.x+this.heroWidth>s.x&&this.hero.x<s.x+s.width&&i+this.heroHeight>s.y&&i<s.y+s.height){i>this.hero.y?(this.hero.y=s.y-this.heroHeight,this.isJumpingFromGround=!1):i<this.hero.y&&(this.hero.y=s.y+s.height,this.isJumpingFromGround=!1),this.hero.vy=0,e=!0;break}e||(this.hero.y=i)}updateAnimation(){this.hero.vx>.01?this.flipX=!1:this.hero.vx<-.01&&(this.flipX=!0);const t=this.animState;this.isWallSliding?this.animState=3:this.isOnGround?Math.abs(this.hero.vx)>.01?this.animState=1:this.animState=0:this.animState=2,t!==this.animState&&(this.animFrame=0,this.animTimer=0),this.animTimer++,this.animTimer>=6&&(this.animFrame=(this.animFrame+1)%12,this.animTimer=0)}syncToSAB(t,i,e){const s=C;t[s.FRAME_COUNT]=i,t[s.FPS]=e,t[s.HERO_X]=this.hero.x,t[s.HERO_Y]=this.hero.y,t[s.HERO_VX]=this.hero.vx,t[s.HERO_VY]=this.hero.vy,t[s.HERO_HP]=this.hp,t[s.HERO_WIDTH]=this.heroWidth,t[s.HERO_HEIGHT]=this.heroHeight,t[s.HERO_FLIP]=this.flipX?1:0,t[s.HERO_ANIM_STATE]=this.animState,t[s.HERO_ANIM_FRAME]=this.animFrame,t[s.WORLD_SCALE]=this.worldScale,t[s.PLAYER_SCALE]=this.playerScale,t[s.PLAYER_OFFSET_Y]=this.playerOffsetY}getSnapshot(){return{hero:{...this.hero},hp:this.hp,wallJumpTimer:this.wallJumpTimer,wallJumpDirection:this.wallJumpDirection,isWallSliding:this.isWallSliding,spikeDamageTimer:this.spikeDamageTimer,wasInSpike:this.wasInSpike,portalCooldown:this.portalCooldown,isJumpingFromGround:this.isJumpingFromGround,spawnPoint:{...this.spawnPoint},hasCompletedLevel:this.hasCompletedLevel}}loadSnapshot(t){t&&(this.hero=t.hero||this.hero,this.hp=t.hp??this.hp,this.wallJumpTimer=t.wallJumpTimer??0,this.wallJumpDirection=t.wallJumpDirection??0,this.isWallSliding=t.isWallSliding??!1,this.spikeDamageTimer=t.spikeDamageTimer??0,this.wasInSpike=t.wasInSpike??!1,this.portalCooldown=t.portalCooldown??0,this.isJumpingFromGround=t.isJumpingFromGround??!1,this.spawnPoint=t.spawnPoint||this.spawnPoint,this.hasCompletedLevel=t.hasCompletedLevel??!1,this.isInitialized=!0)}modifyHP(t){this.hp=Math.max(0,Math.min(100,this.hp+t))}}const q={HERO_X:0,HERO_Y:1,HERO_HP:2,HERO_ANIM_FRAME:5,HERO_FLIP:6,HERO_WIDTH:7,HERO_HEIGHT:8,HERO_ANIM_STATE:9,WORLD_SCALE:10,PLAYER_SCALE:11,PLAYER_OFFSET_Y:12,UI_BOUNCE:20,GLITCH_INTENSITY:21,VIGNETTE_PULSE:22};class Z extends P{uiBounce=0;glitchIntensity=0;lastHp=-1;update(t,i){if(!this.hasBuffers())return;const e=C,s=q,h=this.logicView[e.HERO_HP];this.lastHp!==-1&&h<this.lastHp&&(this.glitchIntensity=1),this.lastHp=h,this.glitchIntensity*=.92;const r=t/16.67;this.uiBounce+=.05*r;const c=.5+Math.sin(i*.05)*.2;this.outputView[s.HERO_X]=this.logicView[e.HERO_X],this.outputView[s.HERO_Y]=this.logicView[e.HERO_Y],this.outputView[s.HERO_HP]=h,this.outputView[s.HERO_ANIM_FRAME]=this.logicView[e.HERO_ANIM_FRAME],this.outputView[s.HERO_FLIP]=this.logicView[e.HERO_FLIP],this.outputView[s.HERO_ANIM_STATE]=this.logicView[e.HERO_ANIM_STATE],this.outputView[s.HERO_WIDTH]=this.logicView[e.HERO_WIDTH],this.outputView[s.HERO_HEIGHT]=this.logicView[e.HERO_HEIGHT],this.outputView[s.WORLD_SCALE]=this.logicView[e.WORLD_SCALE],this.outputView[s.PLAYER_SCALE]=this.logicView[e.PLAYER_SCALE],this.outputView[s.PLAYER_OFFSET_Y]=this.logicView[e.PLAYER_OFFSET_Y],this.outputView[s.UI_BOUNCE]=Math.sin(this.uiBounce)*5,this.outputView[s.GLITCH_INTENSITY]=this.glitchIntensity,this.outputView[s.VIGNETTE_PULSE]=c}getSnapshot(){return{uiBounce:this.uiBounce,glitchIntensity:this.glitchIntensity,lastHp:this.lastHp}}loadSnapshot(t){t&&(this.uiBounce=t.uiBounce??0,this.glitchIntensity=t.glitchIntensity??0,this.lastHp=t.lastHp??-1)}}T.register({id:E.GAME_1,factory:()=>new F}),T.register({id:E.GAME_2,factory:()=>new G}),T.register({id:E.GAME_3,factory:()=>new $}),T.register({id:E.BH_GAME,factory:()=>new z}),x.register({id:E.GAME_1,factory:()=>new Y}),x.register({id:E.GAME_2,factory:()=>new B}),x.register({id:E.GAME_3,factory:()=>new Z}),x.register({id:E.BH_GAME,factory:()=>new j});const S=new Map,v=new Map,A=new Map,m=new Map;self.onmessage=o=>{const{type:t,stateName:i,payload:e,frameCount:s,fps:h}=o.data;switch(t){case"INIT_SABS":console.log("[Worker] Initializing Buffer Map"),S.clear(),v.clear(),A.clear(),e.buffers&&Object.entries(e.buffers).forEach(([n,u])=>{S.set(n,u),v.set(n,new Float32Array(u)),A.set(n,new Int32Array(u))}),m.forEach((n,u)=>{if(typeof n.setBuffers=="function"){const f={};S.forEach((R,V)=>f[V]=R),n.setBuffers(f)}});break;case"UPDATE_BUFFER":const{name:r,buffer:c}=e;S.set(r,c),v.set(r,new Float32Array(c)),A.set(r,new Int32Array(c)),m.forEach(n=>{if(typeof n.setBuffers=="function"){console.log(`[Worker] Updating buffer views for existing state: ${r}`);const u={};S.forEach((f,R)=>u[R]=f),n.setBuffers(u)}});break;case"CREATE_STATE":if(!m.has(i))try{const n=T.create(i);if(m.set(i,n),S.size>0){const u={};S.forEach((f,R)=>u[R]=f),n.setBuffers(u)}}catch(n){console.error(`[Worker] Failed to create state: ${i}`,n)}break;case"TERMINATE_STATE":m.has(i)?(console.log(`[Worker] Terminated Logic for: ${i}`),m.get(i).destroy(),m.delete(i)):console.warn(`[Worker] Attempted to terminate non-existent state: ${i}`);break;case"TERMINATE_ALL":console.log(`[Worker] Terminating all logic states. Count: ${m.size}`),m.forEach(n=>n.destroy()),m.clear();break;case"INPUT":const a=m.get(i);if(a)if(e.action==="GET_SNAPSHOT"){console.info(`[Worker] [${i}] Generating Snapshot`);const n=o.ports[0];n&&n.postMessage(a.getSnapshot())}else e.action==="LOAD_SNAPSHOT"?(console.info(`[Worker] [${i}] Loading Snapshot`),a.loadSnapshot(e.data)):(console.debug(`[Worker] [${i}] Input: ${e.action||"Unknown Action"}`),a.handleInput(e));else console.error(`[Worker] Received INPUT for unknown state: ${i}`);break;case"TICK":const p=m.get(i);p&&v.size>0&&p.update(v,A,s,h);break;default:console.warn(`[Worker] Unhandled message type: ${t}`);break}}})();
