import{B as l,a as L,b as C,c as D}from"./BHLogicSchema-Hm6nHXsy.js";import{B as g}from"./BaseViewLogic-fTOOk9Vw.js";const X={HERO_X:0,HERO_Y:1,HERO_VX:36,HERO_VY:37,HERO_ROTATION:2,HERO_SCALE:3,HERO_HP_DISPLAY:4,HERO_FRAME:5,HERO_WIDTH:6,HERO_HEIGHT:7,CURRENT_WAVE:10,TOTAL_WAVES:11,WAVE_STATE:12,WAVE_DELAY_TIMER:13,EXIT_DOOR_ACTIVE:14,EXIT_DOOR_X:15,EXIT_DOOR_Y:16,CURRENT_LEVEL:17,BOSS_HP:18,BOSS_VULNERABLE:19,BOSS_X:20,BOSS_Y:21,BOSS_ACTIVE:22,ROCK_COUNT:30,PPROJ_COUNT:31,EPROJ_COUNT:32,MOUSE_RELATIVE:33,MAP_WIDTH:34,MAP_HEIGHT:35},M={STRIDE:10},U={STRIDE:5},N={STRIDE:5};class k extends g{heroRotation=0;globalRockRotation=0;animFrame=0;animTimer=0;update(e,Y){const t=this.logicViews.get("main"),O=this.logicViews.get("rocks"),a=this.logicViews.get("pProjs"),n=this.logicViews.get("eProjs"),o=this.outputViews.get("main"),T=this.outputViews.get("rocks"),c=this.outputViews.get("pProjs"),S=this.outputViews.get("eProjs");if(!t||!O||!a||!n||!o||!T||!c||!S)return;const i=l,E=X,h=t[i.HERO_X],P=t[i.HERO_Y],H=t[i.HERO_HP],r=e/16.67;this.heroRotation+=.03*r,this.animTimer++,this.animTimer>=6&&(this.animFrame=(this.animFrame+1)%3,this.animTimer=0),o[E.HERO_X]=h,o[E.HERO_Y]=P,o[E.HERO_VX]=t[i.HERO_VX],o[E.HERO_VY]=t[i.HERO_VY],o[E.HERO_WIDTH]=t[i.HERO_WIDTH],o[E.HERO_HEIGHT]=t[i.HERO_HEIGHT],o[E.HERO_ROTATION]=this.heroRotation,o[E.HERO_SCALE]=.5+H/100,o[E.MOUSE_RELATIVE]=t[i.MOUSE_RELATIVE],o[E.MAP_WIDTH]=t[i.MAP_WIDTH],o[E.MAP_HEIGHT]=t[i.MAP_HEIGHT],o[E.HERO_HP_DISPLAY]=H,o[E.HERO_FRAME]=this.animFrame;const m=t[i.ROCK_COUNT];o[E.ROCK_COUNT]=m,this.globalRockRotation+=.02*r;for(let s=0;s<m;s++){const R=s*L.STRIDE,_=s*M.STRIDE;T[_]=O[R],T[_+1]=O[R+1];const I=O[R+2],B=(Math.floor(I)%5+1)*.5;T[_+2]=this.globalRockRotation*B+I,T[_+3]=O[R+3],T[_+4]=O[R+4],T[_+5]=O[R+5],T[_+6]=O[R+6],T[_+7]=O[R+7],T[_+8]=O[R+8],T[_+9]=O[R+9]}const V=t[i.PPROJ_COUNT];o[E.PPROJ_COUNT]=V;for(let s=0;s<V;s++){const R=s*C.STRIDE,_=s*U.STRIDE;c[_]=a[R],c[_+1]=a[R+1],c[_+2]=a[R+2],c[_+3]=a[R+3],c[_+4]=a[R+4]}const A=t[i.EPROJ_COUNT];o[E.EPROJ_COUNT]=A;for(let s=0;s<A;s++){const R=s*D.STRIDE,_=s*N.STRIDE;S[_]=n[R],S[_+1]=n[R+1],S[_+2]=n[R+2],S[_+3]=n[R+3],S[_+4]=n[R+4]}o[E.CURRENT_WAVE]=t[i.CURRENT_WAVE],o[E.TOTAL_WAVES]=t[i.TOTAL_WAVES],o[E.WAVE_STATE]=t[i.WAVE_STATE],o[E.WAVE_DELAY_TIMER]=t[i.WAVE_DELAY_TIMER],o[E.EXIT_DOOR_ACTIVE]=t[i.EXIT_DOOR_ACTIVE],o[E.EXIT_DOOR_X]=t[i.EXIT_DOOR_X],o[E.EXIT_DOOR_Y]=t[i.EXIT_DOOR_Y],o[E.CURRENT_LEVEL]=t[i.CURRENT_LEVEL],o[E.BOSS_HP]=t[i.BOSS_HP],o[E.BOSS_VULNERABLE]=t[i.BOSS_VULNERABLE],o[E.BOSS_X]=t[i.BOSS_X],o[E.BOSS_Y]=t[i.BOSS_Y],o[E.BOSS_ACTIVE]=t[i.BOSS_ACTIVE]}getSnapshot(){return{heroRotation:this.heroRotation,globalRockRotation:this.globalRockRotation,animFrame:this.animFrame,animTimer:this.animTimer}}loadSnapshot(e){e&&(this.heroRotation=e.heroRotation??0,this.globalRockRotation=e.globalRockRotation??0,this.animFrame=e.animFrame??0,this.animTimer=e.animTimer??0)}}export{k as BHViewLogic};
//# sourceMappingURL=BHViewLogic-CPipJJCv.js.map
