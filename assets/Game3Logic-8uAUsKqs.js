import{G as c,a as m}from"./Game3LogicSchema-LB8iQ2Jc.js";import{B as f,a as u}from"./BaseDispatcher-CXAw-hAN.js";const g={INITIALIZE:{execute(n,i){n.applyConfig(i),i.mapPath||n.setInitialized(!0)}},SET_MAP_DATA:{execute(n,i){n.setMapData(i),n.setInitialized(!0)}},MOD_HP:{execute(n,i){n.modifyHP(i.amount)}}};class d{constructor(i){this.logic=i}checkIsOnGround(){const i=this.logic.heroState,{width:h,height:o}=this.logic.dimensions,l=this.logic.platformList,t=i.y+o+.1;for(const e of l)if(!(e.isSpike||e.isPortal||e.isVoid||e.isExit)&&!(e.isFallthrough&&(this.logic.isAction("MOVE_DOWN")||i.y+o>e.y+.1))&&i.x+h>e.x&&i.x<e.x+e.width&&t>e.y&&i.y+o<=e.y)return!0;return!1}getWallCollision(){const i=this.logic.heroState,{width:h,height:o}=this.logic.dimensions,l=this.logic.platformList,t=.1;for(const e of l)if(e.isWall&&i.x<=e.x+e.width&&i.x+t>e.x+e.width&&i.y+o>e.y&&i.y<e.y+e.height)return-1;for(const e of l)if(e.isWall&&i.x+h>=e.x&&i.x+h-t<e.x&&i.y+o>e.y&&i.y<e.y+e.height)return 1;return 0}resolveMovement(){const i=this.logic.heroState,{width:h,height:o}=this.logic.dimensions,l=this.logic.platformList,t=i.x+i.vx;for(const s of l)if(!(s.isSpike||s.isPortal||s.isVoid||s.isExit)&&!s.isFallthrough&&t+h>s.x&&t<s.x+s.width&&i.y+o>s.y&&i.y<s.y+s.height){t>i.x?i.x=s.x-h:t<i.x&&(i.x=s.x+s.width),i.vx=0;break}i.vx!==0&&(i.x=t);const e=i.y+i.vy;let r=!1;for(const s of l)if(!(s.isSpike||s.isPortal||s.isVoid||s.isExit)&&!(s.isFallthrough&&(i.vy<0||this.logic.isAction("MOVE_DOWN")||i.y+o>s.y+.1))&&i.x+h>s.x&&i.x<s.x+s.width&&e+o>s.y&&e<s.y+s.height){e>i.y?(i.y=s.y-o,this.logic.isJumping=!1):e<i.y&&(i.y=s.y+s.height,this.logic.isJumping=!1),i.vy=0,r=!0;break}r||(i.y=e)}checkHazardCollision(i){return!!this.getCollidingPlatform(i)}getCollidingPlatform(i){const h=this.logic.heroState,{width:o,height:l}=this.logic.dimensions,t=this.logic.platformList,e=.05;for(const r of t)if(r[i]&&h.x+o-e>r.x&&h.x+e<r.x+r.width&&h.y+l-e>r.y&&h.y+e<r.y+r.height)return r}}class y{constructor(i,h){this.logic=i,this.collision=h}updateSpikeLogic(){const i=this.collision.checkHazardCollision("isSpike");i&&(!this.logic.inSpike||this.logic.spikeTimer<=0)&&(this.logic.modifyHP(-10),this.logic.spikeTimer=120),this.logic.spikeTimer>0&&this.logic.spikeTimer--,this.logic.inSpike=i}updatePortalLogic(){if(this.logic.portalTimer>0){this.logic.portalTimer--;return}const i=this.collision.getCollidingPlatform("isPortal");if(i){const h=this.logic.platformList.filter(o=>o.isPortal);if(h.length>=2){const o=h.find(l=>l!==i);if(o){const{width:l,height:t}=this.logic.dimensions;this.logic.heroState.x=o.x+o.width/2-l/2,this.logic.heroState.y=o.y+o.height/2-t/2,this.logic.portalTimer=60}}}}updateVoidLogic(){if(this.collision.checkHazardCollision("isVoid")){const i=this.logic.heroState,h=this.logic.spawn;i.x=h.x,i.y=h.y,i.vx=0,i.vy=0,this.logic.modifyHP(-20)}}updateExitLogic(){!this.logic.levelCompleted&&this.collision.checkHazardCollision("isExit")&&(this.logic.levelCompleted=!0,self.postMessage({type:"EVENT",name:"LEVEL_COMPLETE"}))}}class x extends f{dispatcher;collision;hazards;hp=100;hero={x:0,y:0,vx:0,vy:0};isOnGround=!1;isWallSliding=!1;wallJumpTimer=0;wallJumpDirection=0;spikeDamageTimer=0;wasInSpike=!1;portalCooldown=0;isJumpingFromGround=!1;hasCompletedLevel=!1;spawnPoint={x:0,y:0};heroWidth=1;heroHeight=1;worldScale=32;playerScale=1;playerOffsetY=0;platforms=[];moveSpeed=.25;jumpPower=-.4;gravity=.04;friction=.5;constructor(){super(c.REVISION),this.dispatcher=new u(this,g,"Game3"),this.collision=new d(this),this.hazards=new y(this,this.collision)}applyConfig(i){this.config=i,this.hp=i.initialHP,this.worldScale=i.worldScale||32,this.playerScale=i.playerScale||1,this.playerOffsetY=i.playerOffsetY||0,this.heroWidth=i.heroWidth||1,this.heroHeight=i.heroHeight||2}setMapData(i){this.platforms=i.platforms,this.hero.x=i.playerStart.x,this.hero.y=i.playerStart.y,this.spawnPoint={x:i.playerStart.x,y:i.playerStart.y},this.hero.vx=0,this.hero.vy=0,this.hasCompletedLevel=!1,i.playerStart.width&&i.playerStart.height&&(this.heroWidth=i.playerStart.width,this.heroHeight=i.playerStart.height)}onUpdate(i,h,o,l){!this.config||!this.isInitialized||(this.isOnGround=this.collision.checkIsOnGround(),this.updateHeroMovement(),this.collision.resolveMovement(),this.hazards.updateExitLogic(),this.hazards.updateSpikeLogic(),this.hazards.updatePortalLogic(),this.hazards.updateVoidLogic(),this.syncToSAB(i,o,l))}isAction(i){return this.inputState&&this.inputState.actions&&this.inputState.actions.includes(i)}updateHeroMovement(){const i=this.collision.getWallCollision(),h=this.isAction("MOVE_LEFT"),o=this.isAction("MOVE_RIGHT"),l=this.isAction("JUMP");let t=0;h&&(t-=1),o&&(t+=1),this.wallJumpTimer>0?(this.hero.vx=this.wallJumpDirection*this.moveSpeed*1.5,this.wallJumpTimer--):t!==0?this.hero.vx=t*this.moveSpeed:(this.hero.vx*=this.friction,Math.abs(this.hero.vx)<.01&&(this.hero.vx=0)),this.isWallSliding=!1,!this.isOnGround&&i!==0&&(i===-1&&t===-1||i===1&&t===1)&&(this.isWallSliding=!0,this.wallJumpTimer=0);let e=this.gravity;this.isJumpingFromGround&&l&&this.hero.vy<0&&(e*=.5),this.isWallSliding&&this.hero.vy>0?(this.hero.vy+=e*.2,this.hero.vy>.1&&(this.hero.vy=.1)):this.hero.vy+=e,l&&(this.isOnGround?(this.hero.vy=this.jumpPower,this.wallJumpTimer=0,this.isJumpingFromGround=!0):i!==0&&(this.hero.vy=this.jumpPower,this.wallJumpDirection=-i,this.wallJumpTimer=15,this.isWallSliding=!1,this.isJumpingFromGround=!1)),this.hero.vy>=0&&(this.isJumpingFromGround=!1),this.hero.vy>.8&&(this.hero.vy=.8)}getPlatformType(i){return i.isExit?5:i.isPortal?4:i.isSpike?3:i.isVoid?2:i.isWall?1:i.isFallthrough?6:(i.isFloor,0)}syncToSAB(i,h,o){const l=this.sharedViews.get("platforms");if(!i||!l)return;const t=c;i[t.FRAME_COUNT]=h,i[t.FPS]=o,i[t.HERO_X]=this.hero.x,i[t.HERO_Y]=this.hero.y,i[t.HERO_VX]=this.hero.vx,i[t.HERO_VY]=this.hero.vy,i[t.HERO_HP]=this.hp,i[t.HERO_WIDTH]=this.heroWidth,i[t.HERO_HEIGHT]=this.heroHeight,i[t.WORLD_SCALE]=this.worldScale,i[t.PLAYER_SCALE]=this.playerScale,i[t.PLAYER_OFFSET_Y]=this.playerOffsetY,i[t.IS_ON_GROUND]=this.isOnGround?1:0,i[t.IS_WALL_SLIDING]=this.isWallSliding?1:0,i[t.WALL_JUMP_TIMER]=this.wallJumpTimer,i[t.WALL_JUMP_DIRECTION]=this.wallJumpDirection,i[t.SPIKE_DAMAGE_TIMER]=this.spikeDamageTimer,i[t.WAS_IN_SPIKE]=this.wasInSpike?1:0,i[t.PORTAL_COOLDOWN]=this.portalCooldown,i[t.IS_JUMPING_FROM_GROUND]=this.isJumpingFromGround?1:0,i[t.HAS_COMPLETED_LEVEL]=this.hasCompletedLevel?1:0,i[t.SPAWN_X]=this.spawnPoint.x,i[t.SPAWN_Y]=this.spawnPoint.y,i[t.MOVE_SPEED]=this.moveSpeed,i[t.JUMP_POWER]=this.jumpPower,i[t.GRAVITY]=this.gravity,i[t.FRICTION]=this.friction;const e=Math.floor(l.length/m.STRIDE),r=Math.min(this.platforms.length,e);i[t.OBJ_COUNT]=r;for(let s=0;s<r;s++){const a=this.platforms[s],p=s*m.STRIDE;l[p]=a.x,l[p+1]=a.y,l[p+2]=a.width,l[p+3]=a.height,l[p+4]=this.getPlatformType(a)}}getSnapshot(){return{hero:{...this.hero},hp:this.hp,wallJumpTimer:this.wallJumpTimer,wallJumpDirection:this.wallJumpDirection,isWallSliding:this.isWallSliding,spikeDamageTimer:this.spikeDamageTimer,wasInSpike:this.wasInSpike,portalCooldown:this.portalCooldown,isJumpingFromGround:this.isJumpingFromGround,spawnPoint:{...this.spawnPoint},hasCompletedLevel:this.hasCompletedLevel}}loadSnapshot(i){i&&(this.hero=i.hero||this.hero,this.hp=i.hp??this.hp,this.wallJumpTimer=i.wallJumpTimer??0,this.wallJumpDirection=i.wallJumpDirection??0,this.isWallSliding=i.isWallSliding??!1,this.spikeDamageTimer=i.spikeDamageTimer??0,this.wasInSpike=i.wasInSpike??!1,this.portalCooldown=i.portalCooldown??0,this.isJumpingFromGround=i.isJumpingFromGround??!1,this.spawnPoint=i.spawnPoint||this.spawnPoint,this.hasCompletedLevel=i.hasCompletedLevel??!1,this.isInitialized=!0)}modifyHP(i){this.hp=Math.max(0,Math.min(100,this.hp+i))}get heroState(){return this.hero}get platformList(){return this.platforms}get dimensions(){return{width:this.heroWidth,height:this.heroHeight}}get spawn(){return this.spawnPoint}get spikeTimer(){return this.spikeDamageTimer}set spikeTimer(i){this.spikeDamageTimer=i}get inSpike(){return this.wasInSpike}set inSpike(i){this.wasInSpike=i}get portalTimer(){return this.portalCooldown}set portalTimer(i){this.portalCooldown=i}get levelCompleted(){return this.hasCompletedLevel}set levelCompleted(i){this.hasCompletedLevel=i}get isJumping(){return this.isJumpingFromGround}set isJumping(i){this.isJumpingFromGround=i}}export{x as Game3Logic};
//# sourceMappingURL=Game3Logic-8uAUsKqs.js.map
